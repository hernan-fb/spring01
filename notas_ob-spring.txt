Spring inyecta según el principio de hollywood: "No me llames ya te llamaremos"
"no declares los objetos, ya te los inyectamos".

Estamos en la versión 6 de spring.

Spring Framework Documentation

Overview
Core

IoC Container Overview, crea un sistema para inyección de
dependencias.

Springboot todo es automático.

Spring Framework, es la base y tiene por objetivo facilitar
todo el desarrollo de las apps empresariales java.

Spring Data: SpringMongoDB, SpringJPA, etc.

Spring Cloud: Solo si se conoce lo anterior, para escalar
una applicación creada en arquitectura monolítica.
Escalarlo horizontalmente requerirá muchos recursos al
servidor. Entonces dividir el código en aps mas pequeñas
se logra con spring cloud.

Spring Security: autenticación.

Maven es una tecnología para consruir proyectos.
	Gestionar el ciclo de vida de los proyectos de software.
	Crear un artefacto / Crear un desplegable 
	pasar los tests.
	cargar dependencias.
	Gestionar el maven site (sitio web donde se muestren
	documentación o reportes de resultados)
	Desde que tenemos que hacer algo real, ofrecer un servicio, necesitamos maven.
	
	La manera más óptima de cargar spring es con springboot.
	
	Spring no es un lenguaje, es un conjunto de clases Java que ya están programadas por la comunidad de desarrolladores de spring, que nosotros vamos a utilizar para simplificarnos las operaciones, y centrarnos en la lógica de negocio.
	
El Artifact es el nombre
El Group Id es por ejemplo el nombre de la empresa, o de un agrupador de proyectos.
En el curso se le dio el nombre "org.springframework"

En version todo lo que lleva snapshot significa que está en desarrollo.

Las dependencias de spring se agregan buscando en mvnrepository.com, buscando "org.springframework".

Spring Context, Spring Test, Spring Web, todos corresponden
a distintas features de spring. 

Muestra que Spring es muy modular.

Al agregarlas al pom, maven va a descargar las dependencias automáticamente al recargar el proyecto (opción maven -> reload project)

#### BEANS.XML

El beans.xml van a ser objetos java normales gestionados por spring.
Spring va a estar en toda la app. Va a arrancar un contenedor de beans en memoria y los va a poder inyectar en diversos lugares según la necesidad.

El bean es un objeto java, gestionado por Spring, tal que Spring lo va a poder inyectar en cualquier sitio que sea necesario. Ya sea através de un atributo, de un método setter o de un constructor.

El bean puede tener argumentos y demás cosas.

Se puede hacer con anotaciones o con xml.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="..." class="...">  
		<!-- collaborators and configuration for this bean go here -->
	</bean>

	<bean id="..." class="...">
		<!-- collaborators and configuration for this bean go here -->
	</bean>

	<!-- more bean definitions go here -->

</beans>
----------------------------------------------
session 02
Al trabajar con los beans, en spring, desde el archivo beans.xml vamos a poder crear tantos beans como queramos.
En lugar de hacer objetos con los constructores con el operador new, los haremos a partir de spring. 
"Le pedimos un objeto a spring"

Si tuviese una interfaz calculadora (excel, casio, cientifica), podría tener muchos beans uno por cada implementación de la interfaz, y podría cambiar la calculadora inyectada como parámetro en el gestor, solamente cambiando el nombre escrito en ref del elemento constructor-arg.

Concepto de Scope o alcance.

scope en el bean puede ser singleton o prototype.
Si no queremos que se pase siempre un singleton de esa clase, se crea con el scope="prototype"

---------------------------------
session 02
En lugar de hacer para todas las clases que quiero se inyecten, tengo la opción de habilitar el escaneo automático con context
<context:component-scan base-package="org.example" />

le digo que escanee todo el paquete org.example para ver si hay algún bean.

ahora bien, también hay que indicarle cuáles clases son beans con la anotación "@Component" en cada clase.

el nombre utilizado en getBeans es el mismo que el nombre de la clase pero sin mayúsculas en la primera letra.
----------------------------------
session 03: Spring Data JPA
Es una familia de proyectos dentro de spring (a su vez spring es un ecosistema de tecnologías para la parte web desde base de datos, microservicios, seguridad, sesión (cuando hay una determinadas peticiones http en un período de tiempo) que est pensada para el acceso a base de datos de una manera consistente e independiente de la tecnologia utilizada. P ej si quiero migrar de postgress a mongo db, que no tenga que cambiar mi código de Java de Spring Data JPA.
Entonces el objetivo de Spring Data JPA tiene por objetivo independizarse de la tecnología.

JDBC es lo utilizado para hacer conexiones, crear la sentencia sql, procesarla.
Por eso Spring Provee Spring Data JDBC, luego por encima está Spring Data JPA.

Java Persistence Api es una api que se dedica a almacenar información, para persistir información (hacerla perdurar en el tiempo).

Para entender cómo funcionaría por debajo JPA, hay que conocer bien las tecnologías específicas, por ejemplo:

Podríamos tener un proyecto con
	Spring Data JPA, que por debajo estaría utilizando
		* JPA, y a su vez
			* Hibernate (una librería de persistencia, hace la traducción de java a sql)
				* JDBC

	Spring Data JPA va a simplificar mucho el uso, pero sería recomendable entender JDBC y Hibernate por ejemplo.
	Si no se usara JPA se debería hacer y configurar muchas cosas con JDBC.
	
Spring Boot, nos permite crear proyectos de spring, de manera super rápida y auto configurable. Y se puede empezar a utilizar para utilizar JPA sin configurar demasiadas cosas.

En lugar de configurar beans, creás un proyecto Springboot y ya está todo configurado.

Spring Initializr va a permitir crear proyectos de spring con springboot de manera super sencilla.

Tipo de proyecto va a ser Maven, que nos deja agregar dependencias de manera cómoda.
Lenguaje va a ser Java.
Versión de springboot, la última. no spapshot, no preview.

1 Group
2 ArtifactID
3 Name
Tenemos que actualizar. 2 es el nombre del proyecto.

Luego el packaging, lo dejamos en .jar
war es para desplegar un tomcat. Springboot trae tomcat embebido.

Para simplificar y trabajar con base de datos se va a cargar dos dependencias:

- uno es Spring Data JPA, que va a permitir guardar datos de manera sencilla.
- La otra es un driver de base de datos. Para no perder tiempo vamos a usar H2 que es una base de datos de tipo archivo o en memoria (dependiendo de cómo lo configuremos) sin necesidad de instalar mysql.

Se crea una clase con método main. El punto de entrada a nuestra aplicación.
Dicha aplicación tiene una única clase SpringApplication, con un método run, que está devolviendo un application context, es decir un contenedor de beans.

Entonces a esto que genera Springboot automáticamente yo podría aplicarle el método getBean("..."), pero no se le va a dar ese uso, sino que se va a utilizar la app normalmente.

APPLICATION PROPERTIES
El archivo application.properties, que servirá por ejemplo en este caso para configurar la base de datos.

CONSTRUCTORES
.Normalmente estos frameworks hacen uso del constructor vacío y luego de inyectan los parámetros.
- Un constructor con todos los parámetros para crear objetos manualmente de ser necesario.


Persistencia / Creación de repositorio.
Consiste en marcar las entidades que se van a persistir en la base de datos. Esto se hace escribiendo la anotación @Entity en la clase que se va a guardar con JPA.
La clave primaria se anota con @Id sobre el atributo privado de la pk.
Y con la anotación @GeneratedValue(strategy = GenerationType.IDENTITY), que establece que se va a generar incrementos automáticos e iguales en cada nuevo registro. También me refiero a la pk, en este caso sobre cómo se va generar en el id.

Un registro de la entidad equivale a un registro de una tabla, y cada atributo corresponde a una columna.

REPOSITORIO
El repositorio le indica a spring boot que a partir de esa interfaz se tiene que crar un bean.
Se indica con la anotación @Repository, y esa anotación tiene la misma ruta de dependencia que la que spring usa @Component para indicarle a spring que es un bean, "org.springframework" es la ruta que digo.

La interfaz que modelizará el repositorio, se tiene que llamar igual que la entidad sobre la cual queremos persistir, seguido del sufijo Repository. Por ejemplo CocheRepository.

Va a ser Spring quien implemente esta interfaz, no nosotros. Va a ser spring quien cree un objeto del tipo de esa interfaz.
Spring va a escanear la interfaz, va a crear un bean y va a inyectar en cualquier parte de la aplicación

Necesito crear una conexión, crear una sentencia, ejecutarla. Esto se va a hacer desde una clase Repositorio. Va a ser de una manera simplificada porque lo va a gestionar todo spring.

A nivel práctico se consigue diciendo que la interfaz extiende JPARepository, haciendo click en esa interfaz JPARepository, se observa que tiene todos los métodos que van a permitir hacer CRUD (Create, Read, Update, Delete) .

Lo único que hay que tner en cuenta que JpaRepository pide dos datos: el tipo de dato que quiero almacenar y el id, la pk. <T, ID>.

entonces el extends quedaría por ejemplo

public interface CocheRepository extends JpaRepository<Coche, Long> {
}

con esto solo en la interfaz CocheRepository y con la anotación correspondiente "@Repository" se va a poder guardar, recuperar, ordenar resultados, filtrar, paginar


Volviendo a Main, cómo utilizamos todo esto?
Normalmente desde donde podríamos hacer uso de todo esto es a través de un controlador, o desde un servicio. Pero a esa parte todavía no hemos llegado, y se va a hacer en próximas sesiones.
Por ahora se va a hacer desde la aplicación principal Main. Lo que pasa es que el main, es un método´ estático y entonces no se va a poder usar inyección ahi.
Spring me da esto:
		SpringApplication.run(ObSpringbootDataApplication.class, args);
pero quiero transformarlo para tener un context del que pueda extraer beans (que ya fueron anotados y van a poder ser generados automáticamente gracias a las anotaciones).

	el run devuelve un ConfigurationApplicationContext, el cual extiende ApplicationContext.
	ApplicationContext es la clase del objeto context, del cual se obtienen los beans.
	
	entonces puedo cambiarlo a:
	
	ApplicationContext context = SpringApplication.run(ObSpringbootDataApplication.class, args);
	
	CocheRepository repository = context.getBean(CocheRepository.class);
	
	System.out.println(repository.count()); // devuelve que hay 0 registros.

	Coche toyota = new Coche(null, "Toyota", "Prius", 2023);
	repository.save(toyota);
	
	System.out.println("El número de coches en la base de datos es: "+repository.count());
-------------------------------------
session04
	Qué es spboot, cómo se crean proyectos con sb, qué tipos de dependencias vamos a encontrar, cómo emplearlas en nuestros proyectos, y cómo va a ser la gestión de dependencias en nuestro proyectos.
	
	la idea es que la programación con java sea más productiva, más sencilla..
	SpringFramework es el core, el conjunto de clases, interfaces a partir de lo cual lo demás se basa.
	Spring Data, de cara a conectarnos a una base de datos. Tanto para bd sql como no sql.
	Spring boot, es spring auto configurado, un proyecto de spring normal necesita inicializar el contenedor de beans, 
	Trae un servidor apache tomcat embebido. Sino con spring hay que descargar el apache tomcat. el 10 ya incluye jakarta. Habría sino que descargar del sitio de apache un servidor zip, descomprimirlo y configurarlo.
	Trae sboot dependencias starter, que marcando una opción ya esta todo descargado y configurado.
	La doc oficial es recomendale de ser leida.
	start.spring.io es la pagina oficial de springboot.
	
	El starter son las dependencias maven. Agregándolo trae todas las dependencias necesarias para utilizar esa funcionalidad. Por ejemplo el starter de springboot, con tan solo agregarlo como una dependencia maven mas, tendremos lo necesario para crear aplicaciones web, por lo tanto trae todas las dependencias necesarias para crear controladores rest o controladores mvc, el apache tomcat embebido, jackson y todas las librerías necesarias para parsear a/de json y cosas varias para la parte web. Es decir que con tan solo agregar "una cosa" (starter), ese starter se va a encargar de traer lo de más. A nivel de código es como una dependencia maven más en el pom.
	
	Faltaría la parte web, que se quiere explorar en estas 3 sesiones (4,5,6): Cómo crear una api REST y en qué consiste eso. Para esto tenemos que agregar Spring Web, que nos va a proporcionar todo lo necesario para crear controladores, los cuales no son más que clases normales de java, con una notación especial arriba de todo. Esto va a poder crear controladores de tipo REST y controladores de tipo MVC. Controladores que reciben peticiones http y hacen algo con esas peticiones. Guardan en base de datos, por ej. En lugar de arrancar con un método main, reciben peticiones http en distintos métodos.
	
	Spring boot dev tools nos vaa permitir mejorar la experiencia de desarrollo, para que por ejemplo no tengamos que andar parando la app y volviendo a ejecutarla para desplegar los cambios en el apache tomcat embebido. Y conseguir una app web constantemente en ejecucióń.
	
	
	en application.properties poner server.port=8081 y se cambia el puerto en el que se levanta el servidor de apache tomcat.
	
	Notaciones para persisitir en JPA con base de datos:
	* @Entity, ccuidado que provenga de jakarta persistence app.
	* @Id, jakarta persistence
	* @GeneratedValue(strategy=GenerationType.IDENTITY)
	* @Table(name="cualquierotronombre")
	
	* Interfaz p.ej. BookRepository extends JpaRepository<Book,Long>
----------------------------------------------------------------
session 05
Un servicio REST va a ser un punto de comunicación con la app pero desde el exterior (no desde el intellij). La app se va a ejecutar en un servidor, y cómo va a ser accesible? A través de peticiones http a un determinado puerto que la app va a estar escuchando, por defecto el 8080.
Si yo tengo la ip, y el puerto (debería estar abierto para poder acceder), podemos acceder y hacer la consulta que hayamos programado.

Necesitamos dos dependencias starter web y springweb dev tools (opcional esta última, para no tener que recompilar con cada cambio).
Spring Web puede construir web apps con RESTful (devuelve datos en JSON, para intercambio de datos nativo de javascript) o con Spring MVC (devuelve html que el navegador va a interpretar). Rest permite acoplar el front con el back end
y hacer arquitecturas de microservicios.

Los microservicios, consiste en dividir una aplicación en piezas más pequeñas y manejables, independientes unas de otras pero que se puedan comunicar entre sí, tal que pueden ser reemplazadas en cualquier momento. Implica menores costos, mayor dificultad de implementación y mayor escalabilidad.

Los datos llegarían desde un navegador o dispositivo movil por ej. 
En el enfoque tradicional de arquitectura monolítica hay una sola app donde se despliega todo y cada vez manejarla es más dificil, y si estamos 10 personas durante años cada vez va a pesar más y mas, y la manera de escalar esa app es añadiendo más ram y cpu al servidor.
Por contrario la alternativa springboot para escalarla se puede solucionar con mas recursos para uno o dos servicios. 

Volviendo, necesitamos una clase que devuelva json para la comunciación con la interfaz exterior. A estas clases se les llama controladores, pues gestionan peticiones http.
Luego tenemos Modelo, que tiene las entidades, repositorio y servicios.
Luego Vista, las apps chiquitas entre si no necesitan compartirse la vista. La vista es solamente para que una persona en el navegador lo vea.

En spring hay dos tipos de controladores:
1. @RestController que nos va a permitir trabajar con json
2. @Controller que nos permite cargar vistas en html, no lo vamos a utilizar. Es para SpringMVC. Aqui no tendríamos vistas.

El controlador se crea con la anotación @RestController

Ahora que la app empieza a crecer, se hace necesario crear un paquete para los controladores, otro para los modelos / entidades.
Pero con cuidado, porque la notación @SpringBootApplication indica que tiene escaneo automático, por lo que no puedo mover la clase de la app principal, ni tampoco alejarme del paquete inicial.

La publicación en internet se hace por una serie de anotaciones que tienen la palabra Mapping. Estas son:
1. GetMapping
2. PostMapping
3. DeleteMapping
4. PutMapping

vienen de org.springframework.web, y de manera que llevan un parámetro string que es de url, de manera que cuando despliegue la aplicación, podré acceder con la url_servidor/parametro_en_string.

Para que el proyecto se compile automáticamente se requieren varios pasos:
1. tener agregada la dependencia SpringDevTools springweb dev tools
2. Ir a settings -> Advanced Settings -> Allow auto-make to start even if developed application is currently running. (marcar esta opción)
3. Ir a settings -> Build, Execution, Deployment -> Compiler -> Build project automatically (marcar esta opción)


REST quiere decir que los recursos van a estar identificables de manera unequívoca con una URL y van a ser recuperados independientemente de estados. Es decir es Stateless. No necesitaré ejecutar una secuencia de peticiones para que el servicio X funcione. Y se basa en los métodos de https para llevar a cabo las diferentes acciones de CRUD por ejemplo.

En un método que se devuelve una lista de objetos, se observa en postman que llega un json. Esto es gracias a una librería llamada jackson que hace un parseo de java a json para algunos casos. (?)

GET: Se utiliza para pedir información
POST:	Se brinda información.
PUT:	Se brinda información.
DELETE: Es como el get pero para decirle que borre algo.
---------------------------------------------
Session 06:
los input que vienen por ejemplo de la url en un método get, se mapean con la anotación y de la siguiente manera (hay dos opciones):
Opción 1:
@GetMapping("/url/{variable}")
public Entidad metodo(@PathVariable Long variable)

Opcion 2:
@GetMapping("/url/{variable}")
public Entidad metodo(@PathVariable("variable") Long otro_nombre_para_la_variable)

OPTIONAL:
Si estamos usando el método del repositorio jpa find by id, por ejemplo, esto no devuelve un objeto de la entidad directamente, sino que devuelve un objeto tipo Optional, al estilo de:
Optional<Book>, que no es más que un wrapper para gestionar el caso de que se devuelva un objeto null.

El optional entonces nos permite desenvolver tanto un null como un objeto en este ejemplo del tipo Book.

Optional<Book> bookOpt = bookRepository.findById(id);
- return bookOpt.orElse(null); // retorna book o null si bookOpt es nulo.

El problema de esta última versión (y las anteriores) es que en caso de que la respuesta sea null el status_response es 200 (ok).
Entonces habría que hacer lo siguiente:

RESPONSE ENTITY:
El response entity es un tipo especial de dato para spring framework para devolver respuestas http.

if (bookOpt.isPresent()) {
	return ResponseEntity.ok(bookOpt.get());
} else {
	return ResponseEntity.notFound().build();
}
//alternativa: if (bookOpt.isEmpty()) { ...

//functional style:
//return bookOpt.map(ResponseEntity::ok).orElseGet(() -> ResponseEntity.notFound().build());

El notFound() es una cabecera pura, por eso se utiliza el build sin ningún parámetro.

COLISION:
Si hay una misma url para dos métodos iguales (ambos post, o ambos get, etc...) entonces hay colisión.

Si hay una misma url para  para dos métodos distintos (por ej uno post y otro get) entonces no hay colisión.

POST:
    @PostMapping("/api/books")
    public Book create(@RequestBody Book book) {
        return repository.save(book);
    }
En este ejemplo se guarda directamente con las anotaciones @RequestBody.
Vale aclarar que si hubiese que hacer algún procesamiento como validación, en una app real, se crearía una clase intermedia de tipo Servicio, y si hay un problema que se haga un roll back de los cambios de la base de datos. Por ahora eso no se va a hacer.

La base de datos está reinicializándose en cada inicio del sistema, por lo que por ahora se borran todos los registros que se guarden con este método post.

SI SE ENVIAN HEADERS EN EL METODO HTTP:

Se pueden extraer con la anotación @RequestHeader y el tipo HttpHeader,

public void utilizo_headers(@RequestHeader HttpHeader headers) {
System.out.println(headers.get("User-Agent"));
}

El user agent imprime quién está enviando la solicitud, firefox, windows, linux, postman, un programa python, etc.

Hay muchos ataques encaminados a determinados user-agents. Hay extensiones que permiten cambiarlo.

-----------------------------------------
Session 07
Si llamamos al método de getById un número que no existe, nos devuelve 404 not found.
Pero si ingresamos cualquier texto que no pueda ser un id, nos devuelve 400 bad request, con un json con una trace de una excepción.

en application.properties se puede configurar el parámetro server.error por ejemplo setearlo a:

server.error.include-message=never
server.error.include-stacktrace=never

de manera de no violar el encapsulamiento de la implementación. En otras palabras, esto podría dar problemas de seguridad si fuese visible desde el exterior mediante las trazas de error.

junto al response entity se puede acoplar un dataTransferObject para mandar mensajes por ejemplo al crear un libro con el nombre repetido.

UPDATE ON DATA BASE PutMapping
Normalmente para actualizar un registro, se usa el método Put de http. Para crear se usa Post.
Esto es una convención.

para esto se hace análogamente a los otros casos, ahora con la anotación @PutMapping

Las cabeceras del request se utilizan para enviar información al servidor.

TimeZone, nro de pagina, sistema operativo, nro de elementos que queremos recuperar...

Lo normal en el update es llamar a una clase entre medio, y que el guardar lo haga esa clase intermedia. Es muy común recuperar el objeto original de la base de datos y mediante los setter guardando cada una de las propiedades que cambiaron.
De esa manera se tiene el cuidado de preservar la información de cambios indebidos.

Los errores van gestionados en la capa de servicios para que el controlador no quede tan cargado.

## Borrar DELETEMAPPING

    @DeleteMapping("/api/book/{id}")
    public ResponseEntity<Book> delete(@PathVariable Long id) {
        repository.deleteById(id);
        return ResponseEntity.noContent().build();
	}
Existe el concepto de integridad referencial, y entonces si necesitamos borrar un libro del cual dependen otras tablas, si no lo configuramos bien se puede generar una excepción.
Por eso en caso de borrado conviene capturar las excepciones y gestionarlas.

------------------------------------------
Session 08

SWAGGER
se va a usar una dependencia llamada Spring Fox boot starter, que tiene un sitio "SpringFox Reference Documentation"

Swagger es una herramienta de código abierto para diseñar, construir, documentar y consumir servicios web RESTful. Proporciona una interfaz de usuario para la documentación de API y permite a los desarrolladores probar y depurar sus servicios web.

Springfox, por otro lado, es una biblioteca de código abierto que se integra con Spring Framework para generar documentación de API en formato Swagger. Proporciona anotaciones específicas de Spring para documentar los controladores de Spring MVC y los servicios RESTful.

En resumen, Swagger es una herramienta independiente para diseñar y documentar servicios web RESTful, mientras que Springfox es una biblioteca que se integra con Spring Framework para generar documentación de API en formato Swagger.

Las clases respectivas a esta funcionalidad van a estar en un paquete específico llamado "config" en el mismo nivel que los otros paquetes (entities, controller, repositories)

Así como las clases de controladores tienen la anotación @Controller y el paquete de entidades tiene la anotación @Entity, las clases del paquete config van a tener la anotación @Configuration


Lo primero que vamos a generar es un método api, que devuelve un objeto Docket.

Este objeto Docket sigue el patrón de diseño Builder, y está pensado para ser la interfaz primaria en el framework SpringFox.

Al método api se le pone la anotación @Bean para indicar que es un bean que debe ser inyectado a disposición dicho objeto, donde corresponda.
Va agenerar una web, la documentación dinámicamente. Si yo creo un nuevo método, se va a crear y actualizar esa documentación.

Al ser un builder, se puede hacer lo que se conoce como "method Chaining" y hacer sucesivas llamadas concatenando métodos porque siempre devuelve el mismo objeto builder, todo en la misma linea de código. 

http://localhost:8080/swagger-ui/index.html

Agregar esta dependencia, ya que springfox funciona con swagger y este a su vez utiliza la capa de spring doc

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.0.2</version>
        </dependency>
		
La visualización de la documentación es swagger ui, pero la documentación en si es spring doc

en application.properties
springdoc.pathstomatch = 

poner los paths de los controladores que quiero que se publiquen. De esta manera puedo ocultar algun paquete.

No anduvo Swagger por si mismo, asique hay que usar otro framework, como OpenApi

========================================================================================================

Session 09 testing con Junit

Testing automatizado: Código que prueba el código. No es manual.

Testing unitario prueba las unidadesde código.

Por ej se puede testear los controladores, ...etc

En cuanto a la clase generada en el package test, si cada método no tiene el @Test como anotación, no permite ejecutar nada. Es decir que para que sea un test debe tener esa anotación. Generalmente su nombre termina por la palabra Test.

Para testear un controlador, tengo que lanzar peticiones http y recibir respuestas response entity, por lo cual hay que testear de una manera particular.
Una manera de hacer esto es la siguiente:
Empezamos mediante la anotación 
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT )

Seguido creo un objeto privado

private TestRestTemplate testRestTemplate;

entrando con ctrl click se puede ver y descargar los sources y leer el javadoc.

Luego creo un 

@Autowired
private RestTemplateBuilder restTemplateBuilder;

el cual nos va a permitir construir el TestRestTemplate indicándole la url. Y lo creamos con la anotación autowired para decirle a Spring que lo inyecte automáticamente.

En un método beforeEach voy a setear la url y el puerto al que vamos a hacer peticiones en cada método de test.

SetUp method es un método que se ejecuta antes de cada método.
BeforeClass method es un método que se ejecuta antes de todos los métodos de la clase. @BeforeAll debe ser un método estático, ya que se ejecuta antes de todas las pruebas de la clase y no tiene acceso a las instancias de la clase.
TearDown method es un método que se ejecuta después de cada método de la clase.
AfterClass method es un método que se ejecuta después de todos los métodos (quizás sea antes de borrar la instancia con el garbage collector? No lo sé).

    @LocalServerPort
    private int port;
	/* otra manera equivalente
	@Value("${local.server.port}")
	private int port;
	*/

@BeforeEach
    void setUp() {
        restTemplateBuilder = restTemplateBuilder.rootUri("http://localhost:"+port);
        testRestTemplate = new TestRestTemplate(restTemplateBuilder);
    }
	
el testRestTemplate nos va a permitir generar los métodos http.

En lugar de hacer las llamadas desde postman o desde swagger (desde el navegador), se hace automáticamente desde java como distintos tests.

testRestTemplate.getForEntity("/hola",String.class);

hay que decirle qué tipo de dato va a ser esperado.

nos devuelve un ResponseEntity.

ResponseEntity<String> en este caso.

El response entity tiene todos los datos de una peticion http:
	-status (sting)
	-status code (int)
	-body
	-headers
por ejemplo quiero comprobar el status_code

==============================================
Session 10

Apache Maven además de agregar y gestionar dependencias, tiene una serie de plugins vinculados al ciclo de vida del proyecto. Donde hay 3 ciclos de vida principales: Default, Clean y Site.

Algunas de las fases más empleadas son:
- Fase Clean, es para limpiar la carpeta target. Esta carpeta, se genera automáticamente, y el contenido de la misma es los ejecutables de la app.
- Fase Validate
- Fase Compile
- Fase test
- Fase Package
- Fase Verify
- Fase Install
- Fase Site
- Fase Deploy

De esas fases, las fases del ciclo de vida de Clean son:
	- pre-clean
	- clean
	- post-clean
	El ciclo de vida clean es para borrar la carpeta tarjet, para que en la próxima ejecución todo parta desde cero y no se extiendan los problemas de una compilación a la siguiente.
	
las fases del ciclo de vida Default son:
	- validate
	- initialize
	- generate-resources
	- process-resources
	- compile, compilar el código
	- process-classes
	- generate-test-resources
	- process-test-resources
	- test-compile
	- process-test-classes
	- test, pasar los tests
	- prepare-package
	- package, empaquetar la aplicación en un formato distribuible, por ej en formato JAR (teniendo instalado java podremos ejecutar la applicacion).
	- pre-integration-test
	- integration-test
	- post-integration-test
	- verify
	- install, instala el mismo artefacto generado. Porque al jar se le asocia un artefacto (artifact). Con install se instala el artefacto en el repositorio local, por si desde otro proyecto lo necesito.
	- deploy
	
El ciclo de vida site, nos permite crear la documentación de la web, nos permitiría generar una página web que se auto genera con reportes varios. Y sus fases son:
	- pre-site
	- site
	- post-site
	- site-deploy


Es decir, mientras estamos en la fase de desarrollo, está bien ejecutar la aplicación desde el run del intellij, pero una vez la app realizada, en un servidor no bastaría esto. Para conseguir un ejecutable, en la pestaña Maven, en caso de que no aparezca se puede buscar desde view -> Tool Windows -> Maven. O sino se puede crear una configuración desde edit configurations -> + -> Maven -> poniéndolo en command line. 
Pero teniendo las opciones por defecto en intellij, con darle doble click a la fase deseada ya es suficiente, porque se ejecuta el comando correspondiente que está preconfigurado.


En la página web de Apache Maven, se indica que los ciclos de vida son:
Default: Nos trae todas las fases más populares como: compilar el código(compile), hacer los tests (test), empaquetar la applicación (package) (con un comando java -jar, teniendo instalado java en nuestro sistema), install que instala el artefacto generado (artefacto es lo que se genera cuando se compila y empaqueta). AL trabajar con Maven tenemos un repositorio de artefactos gestionado por Maven.
Clean : Para que en la próxima ejecución se parta de cero y no haya cacheo desde una construcción a la siguiente. Y no hayan problemas de una construcción a otra consrtucción.
Site: que nos permitiría generar la documentación de la web.
una página web que se autogenera con reportes de testing, etc.

Cada vez que con maven ejecutamos un comnado de un ciclo de vida de una fase, se van a ejecutar todas las fases previas.

Podemos ejecutar package. Cada vez que se ejecuta package se ejecutan todas las etapas previas: compile, test y se generan los desplegables. Esto significa que package también va a compilar la aplicación.

en la carpeta target se genera un archivo .jar, que viene de la sigla Java Archive. Con este archivo vamos a poder ejecutar la aplicación de la terminal.

si voy con la linea de comandos con cd, y ls, puedo ejecutar el archivo con java (para eso hay que tener configurado la variable de entorno de java en el sistema).

java --version

<-- indica si tengo instalado java y si va a funcioanr el ejecutar el archivo jar.


java -jar .\archivoDelProyecto.jar 

<-- me va a arrancar la aplicación de spring igual a si la arranco con el botón de play.

Este archivo, entonces, se puede llevar a un servidor que tenga java instalado.

Lo que se suele hacer antes del package es el clean, de manera de vaciar la carpeta target antes de generar los archivos ejecutables que serán luego utilizados.

APPLICATION.PROPERTIES

app.message = mensaje desde el archivo application.properties

puedo guardar variables de la app generales, o de configuración.

Y cargarlas desde org.springframework.beans.factory.annotation.Value;

@Value("${app.message}")
String message;

lo cual inyecta una propiedad del archivo application.properties dentro del código java.

Todo lo que sean herramientas, configuraciones, base de datos, externos a java van a estar definidos en ese archivo, de manera de cambiar el archivo por otro y cambiar el comportamiento sin necesidad de recompilar el código java.


Si tengo otros archivos .properties, hay una propiedad llamada: 

spring.profiles.active=dev

esto hace que podamos crear un jar y archivos .properties externos con propiedades diferentes, y que la misma aplicación funcione para múltiples entornos (prod y test por ejemplo, con distintas bases de datos y conexiones).