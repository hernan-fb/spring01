Spring inyecta según el principio de hollywood: "No me llames ya te llamaremos"
"no declares los objetos, ya te los inyectamos".

Estamos en la versión 6 de spring.

Spring Framework Documentation

Overview
Core

IoC Container Overview, crea un sistema para inyección de
dependencias.

Springboot todo es automático.

Spring Framework, es la base y tiene por objetivo facilitar
todo el desarrollo de las apps empresariales java.

Spring Data: SpringMongoDB, SpringJPA, etc.

Spring Cloud: Solo si se conoce lo anterior, para escalar
una applicación creada en arquitectura monolítica.
Escalarlo horizontalmente requerirá muchos recursos al
servidor. Entonces dividir el código en aps mas pequeñas
se logra con spring cloud.

Spring Security: autenticación.

Maven es una tecnología para consruir proyectos.
	Gestionar el ciclo de vida de los proyectos de software.
	Crear un artefacto / Crear un desplegable 
	pasar los tests.
	cargar dependencias.
	Gestionar el maven site (sitio web donde se muestren
	documentación o reportes de resultados)
	Desde que tenemos que hacer algo real, ofrecer un servicio, necesitamos maven.
	
	La manera más óptima de cargar spring es con springboot.
	
	Spring no es un lenguaje, es un conjunto de clases Java que ya están programadas por la comunidad de desarrolladores de spring, que nosotros vamos a utilizar para simplificarnos las operaciones, y centrarnos en la lógica de negocio.
	
El Artifact es el nombre
El Group Id es por ejemplo el nombre de la empresa, o de un agrupador de proyectos.
En el curso se le dio el nombre "org.springframework"

En version todo lo que lleva snapshot significa que está en desarrollo.

Las dependencias de spring se agregan buscando en mvnrepository.com, buscando "org.springframework".

Spring Context, Spring Test, Spring Web, todos corresponden
a distintas features de spring. 

Muestra que Spring es muy modular.

Al agregarlas al pom, maven va a descargar las dependencias automáticamente al recargar el proyecto (opción maven -> reload project)

#### BEANS.XML

El beans.xml van a ser objetos java normales gestionados por spring.
Spring va a estar en toda la app. Va a arrancar un contenedor de beans en memoria y los va a poder inyectar en diversos lugares según la necesidad.

El bean es un objeto java, gestionado por Spring, tal que Spring lo va a poder inyectar en cualquier sitio que sea necesario. Ya sea através de un atributo, de un método setter o de un constructor.

El bean puede tener argumentos y demás cosas.

Se puede hacer con anotaciones o con xml.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="..." class="...">  
		<!-- collaborators and configuration for this bean go here -->
	</bean>

	<bean id="..." class="...">
		<!-- collaborators and configuration for this bean go here -->
	</bean>

	<!-- more bean definitions go here -->

</beans>
----------------------------------------------
session 02
Al trabajar con los beans, en spring, desde el archivo beans.xml vamos a poder crear tantos beans como queramos.
En lugar de hacer objetos con los constructores con el operador new, los haremos a partir de spring. 
"Le pedimos un objeto a spring"

Si tuviese una interfaz calculadora (excel, casio, cientifica), podría tener muchos beans uno por cada implementación de la interfaz, y podría cambiar la calculadora inyectada como parámetro en el gestor, solamente cambiando el nombre escrito en ref del elemento constructor-arg.

Concepto de Scope o alcance.

scope en el bean puede ser singleton o prototype.
Si no queremos que se pase siempre un singleton de esa clase, se crea con el scope="prototype"

---------------------------------
session 02
En lugar de hacer para todas las clases que quiero se inyecten, tengo la opción de habilitar el escaneo automático con context
<context:component-scan base-package="org.example" />

le digo que escanee todo el paquete org.example para ver si hay algún bean.

ahora bien, también hay que indicarle cuáles clases son beans con la anotación "@Component" en cada clase.

el nombre utilizado en getBeans es el mismo que el nombre de la clase pero sin mayúsculas en la primera letra.
----------------------------------
session 03: Spring Data JPA
Es una familia de proyectos dentro de spring (a su vez spring es un ecosistema de tecnologías para la parte web desde base de datos, microservicios, seguridad, sesión (cuando hay una determinadas peticiones http en un período de tiempo) que est pensada para el acceso a base de datos de una manera consistente e independiente de la tecnologia utilizada. P ej si quiero migrar de postgress a mongo db, que no tenga que cambiar mi código de Java de Spring Data JPA.
Entonces el objetivo de Spring Data JPA tiene por objetivo independizarse de la tecnología.

JDBC es lo utilizado para hacer conexiones, crear la sentencia sql, procesarla.
Por eso Spring Provee Spring Data JDBC, luego por encima está Spring Data JPA.

Java Persistence Api es una api que se dedica a almacenar información, para persistir información (hacerla perdurar en el tiempo).

Para entender cómo funcionaría por debajo JPA, hay que conocer bien las tecnologías específicas, por ejemplo:

Podríamos tener un proyecto con
	Spring Data JPA, que por debajo estaría utilizando
		* JPA, y a su vez
			* Hibernate (una librería de persistencia, hace la traducción de java a sql)
				* JDBC

	Spring Data JPA va a simplificar mucho el uso, pero sería recomendable entender JDBC y Hibernate por ejemplo.
	
Spring Boot, nos permite crear proyectos de spring, de manera super rápida y auto configurable. Y se puede empezar a utilizar para utilizar JPA sin configurar demasiadas cosas.

En lugar de configurar beans, creás un proyecto Springboot y ya está todo configurado.

Spring Initializr va a permitir crear proyectos de spring con springboot de manera super sencilla.

Tipo de proyecto va a ser Maven, que nos deja agregar dependencias de manera cómoda.
Lenguaje va a ser Java.
Versión de springboot, la última. no spapshot, no preview.

1 Group
2 ArtifactID
3 Name
Tenemos que actualizar. 2 es el nombre del proyecto.

Luego el packaging, lo dejamos en .jar
war es para desplegar un tomcat. Springboot trae tomcat embebido.

Para simplificar y trabajar con base de datos se va a cargar dos dependencias:

- uno es Spring Data JPA, que va a permitir guardar datos de manera sencilla.
- La otra es un driver de base de datos. Para no perder tiempo vamos a usar H2 que es una base de datos de tipo archivo o en memoria (dependiendo de cómo lo configuremos) sin necesidad de instalar mysql.

Se crea una clase con método main. El punto de entrada a nuestra aplicación.
Dicha aplicación tiene una única clase SpringApplication, con un método run, que está devolviendo un application context, es decir un contenedor de beans.

Entonces a esto que genera Springboot automáticamente yo podría aplicarle el método getBean("..."), pero no se le va a dar ese uso, sino que se va a utilizar la app normalmente.

APPLICATION PROPERTIES
El archivo application.properties, que servirá por ejemplo en este caso para configurar la base de datos.

CONSTRUCTORES
.Normalmente estos frameworks hacen uso del constructor vacío y luego de inyectan los parámetros.
- Un constructor con todos los parámetros para crear objetos manualmente de ser necesario.


Persistencia / Creación de repositorio.
Consiste en marcar las entidades que se van a persistir en la base de datos. Esto se hace escribiendo la anotación @Entity en la clase que se va a guardar con JPA.
La clave primaria se anota con @Id sobre el atributo privado de la pk.
Y con la anotación @GeneratedValue(strategy = GenerationType.IDENTITY), que establece que se va a generar incrementos automáticos e iguales en cada nuevo registro. También me refiero a la pk, en este caso sobre cómo se va generar en el id.

Un registro de la entidad equivale a un registro de una tabla, y cada atributo corresponde a una columna.

REPOSITORIO
El repositorio le indica a spring boot que a partir de esa interfaz se tiene que crar un bean.
Se indica con la anotación @Repository, y esa anotación tiene la misma ruta de dependencia que la que spring usa @Component para indicarle a spring que es un bean, "org.springframework" es la ruta que digo.

La interfaz que modelizará el repositorio, se tiene que llamar igual que la entidad sobre la cual queremos persistir, seguido del sufijo Repository. Por ejemplo CocheRepository.

Va a ser Spring quien implemente esta interfaz, no nosotros. Va a ser spring quien cree un objeto del tipo de esa interfaz.
Spring va a escanear la interfaz, va a crear un bean y va a inyectar en cualquier parte de la aplicación

Necesito crear una conexión, crear una sentencia, ejecutarla. Esto se va a hacer desde una clase Repositorio. Va a ser de una manera simplificada porque lo va a gestionar todo spring.

A nivel práctico se consigue diciendo que la interfaz extiende JPARepository, haciendo click en esa interfaz JPARepository, se observa que tiene todos los métodos que van a permitir hacer CRUD (Create, Read, Update, Delete) .

Lo único que hay que tner en cuenta que JpaRepository pide dos datos: el tipo de dato que quiero almacenar y el id, la pk. <T, ID>.

entonces el extends quedaría por ejemplo

public interface CocheRepository extends JpaRepository<Coche, Long> {
}

con esto solo en la interfaz CocheRepository y con la anotación correspondiente "@Repository" se va a poder guardar, recuperar, ordenar resultados, filtrar, paginar


Volviendo a Main, cómo utilizamos todo esto?
Normalmente desde donde podríamos hacer uso de todo esto es a través de un controlador, o desde un servicio. Pero a esa parte todavía no hemos llegado, y se va a hacer en próximas sesiones.
Por ahora se va a hacer desde la aplicación principal Main. Lo que pasa es que el main, es un método´ estático y entonces no se va a poder usar inyección ahi.
Spring me da esto:
		SpringApplication.run(ObSpringbootDataApplication.class, args);
pero quiero transformarlo para tener un context del que pueda extraer beans (que ya fueron anotados y van a poder ser generados automáticamente gracias a las anotaciones).

	el run devuelve un ConfigurationApplicationContext, el cual extiende ApplicationContext.
	ApplicationContext es la clase del objeto context, del cual se obtienen los beans.
	
	entonces puedo cambiarlo a:
	
	ApplicationContext context = SpringApplication.run(ObSpringbootDataApplication.class, args);
	
	CocheRepository repository = context.getBean(CocheRepository.class);
	
	System.out.println(repository.count()); // devuelve que hay 0 registros.

-------------------------------------------
session 05
Un servicio REST va a ser un punto de comunicación con la app pero desde el exterior (no desde el intellij). La app se va a ejecutar en un servidor, y cómo va a ser accesible? A través de peticiones http a un determinado puerto que la app va a estar escuchando, por defecto el 8080.
Si yo tengo la ip, y el puerto (debería estar abierto para poder acceder), podemos acceder y hacer la consulta que hayamos programado.

Necesitamos dos dependencias starter web y springweb dev tools (opcional esta última, para no tener que recompilar con cada cambio).
Spring Web puede construir web apps con RESTful (devuelve datos en JSON, para intercambio de datos nativo de javascript) o con Spring MVC (devuelve html que el navegador va a interpretar). Rest permite acoplar el front con el back end
y hacer arquitecturas de microservicios.

Los microservicios, consiste en dividir una aplicación en piezas más pequeñas y manejables, independientes unas de otras pero que se puedan comunicar entre sí, tal que pueden ser reemplazadas en cualquier momento. Implica menores costos, mayor dificultad de implementación y mayor escalabilidad.

Los datos llegarían desde un navegador o dispositivo movil por ej. 
En el enfoque tradicional de arquitectura monolítica hay una sola app donde se despliega todo y cada vez manejarla es más dificil, y si estamos 10 personas durante años cada vez va a pesar más y mas, y la manera de escalar esa app es añadiendo más ram y cpu al servidor.
Por contrario la alternativa springboot para escalarla se puede solucionar con mas recursos para uno o dos servicios. 

Volviendo, necesitamos una clase que devuelva json para la comunciación con la interfaz exterior. A estas clases se les llama controladores, pues gestionan peticiones http.
Luego tenemos Modelo, que tiene las entidades, repositorio y servicios.
Luego Vista, las apps chiquitas entre si no necesitan compartirse la vista. La vista es solamente para que una persona en el navegador lo vea.

En spring hay dos tipos de controladores:
1. @RestController que nos va a permitir trabajar con json
2. @Controller que nos permite cargar vistas en html, no lo vamos a utilizar. Es para SpringMVC. Aqui no tendríamos vistas.

El controlador se crea con la anotación @RestController

Ahora que la app empieza a crecer, se hace necesario crear un paquete para los controladores, otro para los modelos / entidades.
Pero con cuidado, porque la notación @SpringBootApplication indica que tiene escaneo automático, por lo que no puedo mover la clase de la app principal, ni tampoco alejarme del paquete inicial.

La publicación en internet se hace por una serie de anotaciones que tienen la palabra Mapping. Estas son:
1. GetMapping
2. PostMapping
3. DeleteMapping
4. PutMapping

vienen de org.springframework.web, y de manera que llevan un parámetro string que es de url, de manera que cuando despliegue la aplicación, podré acceder con la url_servidor/parametro_en_string.

Para que el proyecto se compile automáticamente se requieren varios pasos:
1. tener agregada la dependencia SpringDevTools springweb dev tools
2. Ir a settings -> Advanced Settings -> Allow auto-make to start even if developed application is currently running. (marcar esta opción)
3. Ir a settings -> Build, Execution, Deployment -> Compiler -> Build project automatically (marcar esta opción)

